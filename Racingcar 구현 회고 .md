#### Racingcar 구현 회고 

Racingcar 를 구현할 때 중요시 해야 했던 점과 느낀점들을 몇가지 짚어보려고 한다.

* 프로젝트 흐름도는

  > - InputView 에서 사용자 입력을 받고,
  > - 사용자 입력을 InputView 로부터 전달받아 Model 클래스에 해당하는 Racingcar, Car 에서 관련 로직을 구현한다음, 
  > - 결과값을 ResultView 로 전달해서 화면에 출력해준다.
  > - Controller 역할인 Main 클래스에서는 각각 클래스의 객체를 생성해서 Model과 View 간의 결과값, 입력값 등의 전달을 용이하게 해준다. 말하자면, 단절되어 있던 Model 과 View 를 이어주는 역할을 한다.


* 흐름도에 따라 최대한 MVC 구조대로 각각의 클래스에서 하는일을 분리하려고 했는데, 자꾸View 에 Model에만 포함되어야하는 logic 구현이 이루어져서 분리하는데에 시간이 좀 걸렸던것 같다.

* 파라미터 값으로 내가 만든 객체를 넘기는 것이 생소해서 계속 원래있던 타입으로 바꾸어서 코드를 구현했는데, 객체를 직접 넘기는 것이 메서드 간에 데이터를 전달받고 전달해줄 때 좀 더 쉽고, 깔끔한 코드를 구현할 수 있다는 것을 알게 되었다. 

* 또한 객체지향적인 설계에 대해서도 좀 더 생각을 해볼 수 있는 기회였는데, 이번에 프로젝트에서 만든 Car class 의 경우 프로퍼티(상태)로 `position` 을 가지고 있었다. 처음에는 이 프로퍼티와 관련한 로직을 Car class 외부에서 구현을 했었는데, 객체지향 프로그램에서 객체가 필요한 이유는 객체에게 할일을 할당해서 그 일은 온전히 객체에게만 맡기기 위해서이다. 그런데 `position` 에 대한 로직을 외부 클래스에서 구현하면 객체지향적인 설계에 맞지 않기 때문에 다시 코드를 고쳐 Car class 내에서 `position` 에 대한 로직을 구현했다.

* Lambda, stream 을 이용해서 일부 코드를 구현했는데 아직 문법에 익숙하지 않아서 구현에 시간이 좀 걸렸다. 연습이 좀 더 필요한 것 같다.

* 테스트 코드를 짜서 JUnit 을 이용해서 코드를 테스트해봤는데, 테스트 코드 중에 객체가 같은 객체인지 다른객체인지 비교하는 코드가 있었다. 비교를 하기 위해서는 테스트 대상이 되는 클래스에서 

  > Object 클래스의 메소드인
  >
  > 두 객체가 같은 객체인지 비교하는 메소드인 `hashCode()` 와 
  >
  > 두 객체가 담고있는 contents의 내용이 같은지 비교하는 `equals()` 를 
  >
  > Override 해야 했었는데
  >
  > 두 객체가 같은지 다른지 비교할때 `equals()` 도 필요한 이유는 객체가 객체를 담고있을 수 있기 때문이었다. 즉, 객체가 프로퍼티로 다른 객체를 가질 수도 있기 때문에 `equals()` 메소드가 필요했던 것이다.

-----

**equals** :  두 객체의 내용이 같은지, 동등성(equality) 를 비교하는 연산자

**hashCode** : 두 객체가 같은 객체인지, 동일성(identity) 를 비교하는 연산자 